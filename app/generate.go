// Package app provides ...
package app

import (
	"fmt"
	"path"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/koolay/econfig/config"
	"github.com/koolay/econfig/context"
	"github.com/koolay/econfig/dotfile"
	"github.com/koolay/econfig/store"
)

type Generator struct {
	mu sync.Mutex
	wg sync.WaitGroup
}

func NewGenerator() (*Generator, error) {
	gen := &Generator{}
	return gen, nil
}

func (gen *Generator) processKey(prefix string, key string) string {
	key = strings.TrimSpace(key)
	if key == "" {
		return strings.ToLower(fmt.Sprintf("%s_%s", prefix, key))
	} else {
		return strings.ToLower(key)
	}
}

func (gen *Generator) Sync() {
	gen.mu.Lock()
	defer gen.mu.Unlock()
	appList := config.GetApps()
	for _, app := range appList {
		context.Logger.INFO.Printf("sync app: %s \n", app.Name)
		gen.wg.Add(1)
		go func(app *config.App) {
			defer func() {
				gen.wg.Done()
				context.Logger.INFO.Printf("sync app: %s completed \n", app.Name)
			}()
			context.Logger.INFO.Println("start sync app:", app.Name)
			tmplFilePath := path.Join(app.Root, app.Tmpl)
			destFilePath := path.Join(app.Root, app.Dest)
			// load apps
			context.Logger.INFO.Printf("sync app: %s, tmpfile: %s \n", app.Name, tmplFilePath)
			context.Logger.INFO.Printf("sync app: %s, destfile: %s \n", app.Name, destFilePath)
			if tmplMap, err := dotfile.ReadEnvFile(tmplFilePath); err == nil {
				var keys []string
				var originalKeys sort.StringSlice
				for k, _ := range tmplMap {
					originalKeys = append(originalKeys, k)
					keys = append(keys, gen.processKey(app.Prefix, k))
				}
				originalKeys.Sort()
				storage := store.NewStorage()
				if valueMap, err := storage.GetItems(keys); err == nil {
					var lines []string
					now := time.Now().Format("2006-01-02 15:04:05.000000")
					lines = append(lines, fmt.Sprintf("##(%s)THIS IS AN AUTOGENERATED FILE, MODIFY WILL BE LOST!", now))
					for _, k := range originalKeys {
						tmpItem, ok := tmplMap[k]
						if !ok {
							fmt.Println(k)
						}
						if tmpItem.Comment != "" {
							lines = append(lines, "#"+tmpItem.Comment)
						}
						storeKey := gen.processKey(app.Prefix, k)
						if val, ok := valueMap[storeKey]; ok {
							lines = append(lines, fmt.Sprintf("%s=%v", k, val))
						} else {
							lines = append(lines, fmt.Sprintf("%s=%v", k, tmpItem.Value))
						}
					}

					if err := dotfile.WriteLines(lines, destFilePath, 0, 0); err != nil {
						context.Logger.ERROR.Printf("failed to write to %s. error: %s", destFilePath, err.Error())
					}

				} else {
					context.Logger.ERROR.Printf("fetch data failed. %v", err)
				}
			} else {
				context.Logger.ERROR.Printf("errmsg: %s. parse file: %s failed.", err.Error(), tmplFilePath)
			}
		}(app)

	}
	gen.wg.Wait()
	context.Logger.INFO.Println("complete")
}

func (gen *Generator) SyncLoop(interval time.Duration) {
	t := time.NewTicker(interval)
	defer t.Stop()
	for {
		<-t.C
		context.Logger.INFO.Println("syncLoop called")
		gen.Sync()
	}
}
