// Package app provides ...
package app

import (
	"fmt"
	"sort"
	"sync"
	"time"

	"github.com/koolay/econfig/config"
	"github.com/koolay/econfig/context"
	"github.com/koolay/econfig/dotfile"
	"github.com/koolay/econfig/store"
)

type GeneratorConfig struct {
	Interval time.Duration
}

type Generator struct {
	config *GeneratorConfig
	mu     sync.Mutex
	wg     sync.WaitGroup
}

func NewGenerator(config *GeneratorConfig) (*Generator, error) {
	gen := &Generator{}
	gen.config = config
	return gen, nil
}

func (gen *Generator) Sync() {
	gen.mu.Lock()
	defer gen.mu.Unlock()
	appList := config.GetApps()
	for _, app := range appList {
		context.Logger.INFO.Printf("sync app: %s \n", app.Name)
		gen.wg.Add(1)
		go func(app *config.App) {
			defer func() {
				gen.wg.Done()
				context.Logger.INFO.Printf("sync app: %s completed \n", app.Name)
			}()
			context.Logger.INFO.Println("start sync app:", app.Name)
			tmplFilePath := app.GetTmplPath()
			destFilePath := app.GetDestPath()
			// load apps
			context.Logger.INFO.Printf("sync app: %s, tmpfile: %s \n", app.Name, tmplFilePath)
			context.Logger.INFO.Printf("sync app: %s, destfile: %s \n", app.Name, destFilePath)
			if tmplMap, err := dotfile.ReadEnvFile(tmplFilePath); err == nil {
				var keys []string
				var originalKeys sort.StringSlice
				for k, _ := range tmplMap {
					originalKeys = append(originalKeys, k)
					keys = append(keys, app.GenerateStoreKey(k))
				}
				originalKeys.Sort()
				storage, err := store.NewStorage(context.Flags.Global.Backend)
				if err != nil {
					context.Logger.ERROR.Println(err.Error())
					return
				}
				if valueMap, err := storage.GetItems(keys); err == nil {
					var lines []string
					now := time.Now().Format("2006-01-02 15:04:05.000000")
					lines = append(lines, fmt.Sprintf("##(%s)THIS IS AN AUTOGENERATED FILE, MODIFY WILL BE LOST!", now))
					for _, k := range originalKeys {
						tmpItem := tmplMap[k]
						if tmpItem.Comment != "" {
							lines = append(lines, "#"+tmpItem.Comment)
						}
						storeKey := app.GenerateStoreKey(k)
						if val, ok := valueMap[storeKey]; ok {
							lines = append(lines, fmt.Sprintf("%s=%v", k, val))
						} else {
							context.Logger.WARN.Printf("[%s]miss key: %s \n", app.Name, k)
							// lines = append(lines, fmt.Sprintf("%s=%v", k, tmpItem.Value))
						}
					}

					if err := dotfile.WriteLines(lines, destFilePath, 0, 0); err != nil {
						context.Logger.ERROR.Printf("failed to write to %s. error: %s", destFilePath, err.Error())
					}

				} else {
					context.Logger.ERROR.Printf("fetch data failed. %v", err)
				}
			} else {
				context.Logger.ERROR.Printf("errmsg: %s. parse file: %s failed.", err.Error(), tmplFilePath)
			}
		}(app)

	}
	gen.wg.Wait()
	context.Logger.INFO.Println("complete")
}

func (gen *Generator) SyncLoop() {
	t := time.NewTicker(gen.config.Interval)
	defer t.Stop()
	for {
		<-t.C
		context.Logger.INFO.Println("syncLoop called")
		gen.Sync()
	}
}
