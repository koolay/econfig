// Package app provides ...
package app

import (
	"fmt"
	"sort"
	"sync"
	"time"

	"github.com/koolay/econfig/config"
	"github.com/koolay/econfig/context"
	"github.com/koolay/econfig/dotfile"
	"github.com/koolay/econfig/store"
)

type GeneratorConfig struct {
	Interval time.Duration
}

type Generator struct {
	config *GeneratorConfig
	mu     sync.Mutex
	wg     sync.WaitGroup
}

type AppGenerateResult struct {
	sync.Mutex
	Logs    []string
	Success bool
}

type GenerateResult struct {
	AppsMap map[string]*AppGenerateResult
}

func (gr *AppGenerateResult) pushLog(logLevel, text string) {
	defer gr.Unlock()
	gr.Lock()
	gr.Logs = append(gr.Logs, fmt.Sprintf("[%s] %s", logLevel, text))
	if logLevel == "info" {
		context.Logger.INFO.Println(text)
	} else if logLevel == "error" {
		context.Logger.ERROR.Println(text)
	} else if logLevel == "fatal" {
		context.Logger.FATAL.Fatalln(text)
	}
}

func NewGenerator(config *GeneratorConfig) (*Generator, error) {
	gen := &Generator{}
	gen.config = config
	return gen, nil
}

func (gen *Generator) Sync(appList []*config.App) (*GenerateResult, error) {
	gen.mu.Lock()
	defer gen.mu.Unlock()
	if appList == nil || len(appList) == 0 {
		appList = config.GetApps()
	}
	gr := &GenerateResult{}
	for _, app := range appList {
		gen.wg.Add(1)
		appGr := &AppGenerateResult{Success: true}
		gr.AppsMap = make(map[string]*AppGenerateResult)
		gr.AppsMap[app.Name] = appGr
		appGr.pushLog("info", fmt.Sprintf("sync app: %s \n", app.Name))
		go func(app *config.App) {
			defer func() {
				gen.wg.Done()
				appGr.pushLog("info", fmt.Sprintf("sync app: %s completed \n", app.Name))
			}()
			appGr.pushLog("info", fmt.Sprintf("start sync app: %s \n", app.Name))
			tmplFilePath := app.GetTmplPath()
			destFilePath := app.GetDestPath()
			// load apps
			appGr.pushLog("info", fmt.Sprintf("sync app: %s, tmpfile: %s \n", app.Name, tmplFilePath))
			appGr.pushLog("info", fmt.Sprintf("sync app: %s, destfile: %s \n", app.Name, destFilePath))
			if tmplMap, err := dotfile.ReadEnvFile(tmplFilePath); err == nil {
				var keys []string
				var originalKeys sort.StringSlice
				for k, _ := range tmplMap {
					originalKeys = append(originalKeys, k)
					keys = append(keys, app.GenerateStoreKey(k))
				}
				originalKeys.Sort()
				storage, err := store.NewStorage(context.Flags.Global.Backend)
				if err != nil {
					appGr.pushLog("error", err.Error())
					appGr.Success = false
					return
				}
				if valueMap, err := storage.GetItems(keys); err == nil {
					var lines []string
					now := time.Now().Format("2006-01-02 15:04:05.000000")
					lines = append(lines, fmt.Sprintf("##(%s)THIS IS AN AUTOGENERATED FILE, MODIFY WILL BE LOST!", now))
					for _, k := range originalKeys {
						tmpItem := tmplMap[k]
						if tmpItem.Comment != "" {
							lines = append(lines, "#"+tmpItem.Comment)
						}
						storeKey := app.GenerateStoreKey(k)
						if val, ok := valueMap[storeKey]; ok {
							lines = append(lines, fmt.Sprintf("%s=%v", k, val))
						} else {
							appGr.Success = false
							appGr.pushLog("error", fmt.Sprintf("[%s]miss key: %s \n", app.Name, k))
						}
					}

					if appGr.Success {
						appGr.pushLog("info", fmt.Sprintf("sync to dest file %s", destFilePath))
						if err := dotfile.WriteLines(lines, destFilePath, 0, 0); err != nil {
							appGr.Success = false
							appGr.pushLog("error", fmt.Sprintf("failed to write to %s. error: %s", destFilePath, err.Error()))
						}
					}

				} else {
					appGr.Success = false
					appGr.pushLog("error", fmt.Sprintf("fetch data failed. %v", err))
				}
			} else {
				appGr.Success = false
				appGr.pushLog("error", fmt.Sprintf("errmsg: %s. parse file: %s failed.", err.Error(), tmplFilePath))
			}
		}(app)

	}
	gen.wg.Wait()
	context.Logger.INFO.Println("info", "complete")
	return gr, nil
}

func (gen *Generator) SyncLoop() {
	t := time.NewTicker(gen.config.Interval)
	defer t.Stop()
	for {
		<-t.C
		context.Logger.INFO.Println("syncLoop called")
		gen.Sync(nil)
	}
}
